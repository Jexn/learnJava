## 大O符号衡量算法效率

*大O符号标记可以基于输入的大小得到一种衡量算法的时间复杂度的函数。可以忽略函数中的倍乘常量和非主导项。*

对于O(n)、O(n-1)、O(n/2)、O(100n)这样形式的复杂度都可以统一表示为O(n)，-1，1/2、100这种倍乘常量或者常量都可以忽略。

大O标记估算一个算法与输入规模相关的执行时间。如果执行时间与输入规模无关，就称这个算法耗费了*常量时间*(constant time)，用符号O(1)表示。例如，在一个数组中，给定数组的下标获取对应下标的值所耗费的时间即为常量时间，这是因为该时间不会随着数组规模的增大而增长。

常见的算法分析数学求和公式：

1+2+3+...+(n-2)+(n-1) = n(n-1)/2 = O(n^2)

1+2+3+...+(n-2)+n = n(n+1)/2 = O(n^2)

a^0+a^1+a^2+a^3+...+a^(n-1)+a^n = (a^(n+1) -1)/(a-1) = O(a^n)

2^0+2^1+2^2+2^3+...+2^(n-1)+2^n = 2^(n+1) - 1 = O(2^n)

## 动态编程降低复杂度

### 斐波那契额数
```Java
package Chapter22;
import java.util.Scanner;

public class ImprovedFibonacci {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print("计算前N项斐波那契额数:");
        long index = in.nextInt();
        fib(index);
        fib1(index);
    }

    //动态编程方式
    public static long fib(long index){
        long f0 = 0;
        long f1 = 1;
        long f2 = 1;

        if (index == 0){
            return f0;
        }else if (index == 1){
            return f1;
        }else if (index == 2){
            return f2;
        }

        for (int i = 3; i <= index;i++){
            f0 = f1;
            f1 = f2;
            f2 = f0+f1;
        }

        return f2;
    }

    //递归方式
    public static long fib1(long index){
        if (index == 0){
            return 0;
        }else if (index == 1){
            return 1;
        }else {
            return fib(index-1)+fib(index-2);
        }
    }
}

```
通过计算可以得知递归方式的复杂度为O(2^n)，而如果通过动态编程算法的复杂度降为了O(n)。

动态编程是通过解决子问题，然后将子问题的结果结合来获得整个问题的解的过程。递归解决的效率不高，因为子问题相互重叠了。

动态编程的关键思想是只解决子问题一次，并将子问题的结果存储以备后用，从而避免了重复的子问题的求解。

## 排序

- [插入排序](../Code/InsertionSort.java)
插入排序重复地将新的元素插入到一个排好序的子线性表中，直到整个线性表排好序。插入排序算法的复杂度是O(n^2);

- [冒泡排序](../Code/BubbleSort.java)
冒泡排序算法多次遍历数组，在每次遍历中连续比较相邻的元素，如果元素没有按照顺序排列，则互换它们的值。冒泡排序算法的复杂度是O(n^2);

- [选择排序](../Code/SelectSort.java)
选择排序多次遍历数组，查找数组中最小的元素，交换当前元素与最小元素的位置。选择排序的算法复杂度是O(n^2);

- [归并排序](../Code/MergeSort.java)
归并排序将数组分为两半，对每部分递归地应用归并排序。在两部分排好序后，对它们进行归并。归并排序的算法复杂度是O(nlogn);

- [快速排序](../Code/QuickSort.java)
快速排序和归并排序一样采用分而治之的思想，首先确定一个主元的元素，将数组分为两部分，使得第一部分中的所有元素都小于或等于主元，而第二部分中的所有元素都大于主元。对第一部分递归地应用快速排序算法，然后对第二部分递归地应用快速排序算法。快速排序的算法复杂度也是O(nlogn)；

- [堆排序](../Code/HeapSort.java)
堆排序使用的是二叉堆。它首先将所有的元素添加到一个堆上，然后不断移动最大的元素以获得一个排好序的线性表。

上述的插入、冒泡、选择、归并、快速、堆排序都属于通用算法，它们可以实现整数、字符串以及任何可比较对象的排序。基于比较的排序算法的复杂度不会好于O(nlogn)。

桶排序和基数排序是对整数进行排序的高效算法。桶排序算法的工作方式，先是假设键值的范围是从0到t。我们需要t+1个标记为0，1，...，t的桶。如果元素的键值是i，那么就将该元素放入桶i中。每个桶中都放着具有相同键值的元素。桶排序是稳定的。

基数排序的思路就是将这些键值基于它们的基数位置分为子组。然后反复地从最小的基数位置开始，对其上的键值应用桶排序。